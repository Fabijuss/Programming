# Application Building   
#### Outlining the Process of Building an Application.
## Contents
[I. Contents](#contents)   
[II. Introduction](#introduction)   
[III. Algorithms](#algorithms)   
&nbsp;&nbsp;[III.1 Definition](#definition)   
&nbsp;&nbsp;[III.2 Uses](#uses)   
[IV. Development Models](#development-models)   
[V. Development Phases](#development-phases)   
&nbsp;&nbsp;[V.1 Requirements Phase](#requirements-phase)   
&nbsp;&nbsp;[V.2 Design Phase](#design-phase)   
&nbsp;&nbsp;[V.3 Implementation Phase](#implementation-phase)   
&nbsp;&nbsp;[V.4 Testing Phase](#testing-phase)   
&nbsp;&nbsp;[V.5 Maintenance Phase](#maintenance-phase)   
[VI. References/Bibliography](#references)   



## Introduction
This short report will cover the processes which are used in the building of an application, this includes the different models and phases of development. In addition, algorithms and their uses within programming will be explored.

The development process of an application will be split up and looked at in their individual parts. The following parts will be looked at and covered in particular:
+ Requirements   
+ Design   
+ Implementation   
+ Testing   
+ Maintenance   

## Algorithms

### Definition
An algorithm in general terms is a set of rules/instructions used to solve a problem. They can be used to perform from simple to complex tasks. They are often implemented in the form of functions in programming, they act as small programs which can be used by the main program to perform specific tasks.

### Uses
Algorithms are useful in application development as they allow the process to be broken down into smaller parts, so they can be completed in independent chunks. This proves to be especially useful because application development often results in very complex problems which require a lot of code to solve. Additionally, this gives the application a level of modularity during the development process, as parts of the code can be added and removed when needed.

Once the initial problem is discovered, the solution to the problem is laid out most commonly in two forms; flowchart and pseudocode. This allows the problem to be visualised easier and gives an idea of how the algorithm can be used in the final code. Once a design is determined, the algorithm can then be implemented using a chosen programming language. The process of using an algorithm to determine the design and implementation utilises the second and third phases of development.

## Development Models
Application development can be undertaken in a variety of ways, using different methodologies in order to complete the project. As a result, there are a number of different development models commonly used in application development. Each development model uses a different ideology for the development of the application, the main categories being iterative and sequential. However, regardless of the model used, the phases are roughly the same - names or order of the phases may differ.

## Development Phases
The phases of development often vary in different models and applications, varying from 4 to 6 phases. The following are the 5 phases of development commonly used:

### Requirements Phase   
In this phase, the user requirements of the application are established by the client. They are discussed and analysed by the team and upper management in order to determine the appropriate steps to take for the project. This phase is very important as in some development models, you cannot go back to modify the requirements. Also, understanding the client's requirements thoroughly will reduce mistakes and allow for a better final product.

### Design Phase   
Within the design phase, the requirements are further analysed and the steps of how to meet the requirements are outlined. This will cover aspects such as the way the system will be implemented, the user interface, and what the system architecture will be like. It is important to create a good design, as once you start working on the implementation and development you cannot go back to the design phase - not without wasting a lot of time.

### Implementation Phase   
This is the phase in which the application is actually developed into the final product. This phase materialises the design into an application that meets the user requirements laid out by the client. This is done by following the design architecture created in the previous phase and using a programming language to meet the demands, the result should be a working application.

### Testing Phase   
During this phase, the application created in the previous phase is thoroughly tested to ensure that not only is it robust, but that it works as intended. It is vital to perform testing and review of applications before releasing them to the client, and to customers. This phase allows the development team to find any bugs within the application, and fix them before the final product is released.

### Maintenance Phase   
Most software development doesn't end once the product is released, the clients usually require additional development/support such as fixing any bugs missed during the testing phase, future compatibility updates, and potentially new features.

## Conclusion
To conclude, it can be seen how useful and important algorithms are in programming, they help define computing problems in a way that allows for easy design and implementation of a solution to the client's requirements. This is how most modern software applications are built, by utilising the development phases throughout the development process from start to finish, which allows for more streamlined application development.

By using a structured development model to create an application, the software developers are able to break the project down into smaller individual parts. These can be worked on independently from each other and by other people. This type of process is proven to be effective as it has been used to develop most software to date.

Overall, it is clear that both algorithms and structured development models are beneficial to software developers, and should be used in the development of applications in order to have a more efficient process and a better application.

## References
